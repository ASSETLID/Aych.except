.TH OCAMLEXCLI 1

.SH NAME
ocamlexcli 1.0 \- The Objective Caml second pass for uncaught exceptions
analyzer (linking pass) with graphical user interface.



.SH SYNOPSIS
.B ocamlexcli
[
.BI -forcevars
.BI \-I \ lib-dir
]
.I filenames ...



.SH DESCRIPTION

The
.BR ocamlexcli (1)
command is the second pass for the Objective Caml uncaught exceptions
analyzer (linking and displaying pass). This command is invocated with
the names of all the analyzed files ('.cme' files coming from the
analysis of '.ml' files) used by the analyzed program. This includes
the files of the standard library and also the files of the analyzed
program itself. Files must appear in their order of dependency
otherwise an error message will be returned. This means that a file
'foo.cme' depending on a file 'bar.cme' (because 'foo.ml' was
depending on 'bar.ml') should appear in the command line before
'bar.cme'. Opposite to
.BR ocamlexcl
the
.BR ocamlexcli
displays the results of the analysis via a graphical user
interface. This interface is based on a windows system, mouse driven,
and allows the user to see the results of the analysis after they have
been treated and simplified. The simplification allows to read set of
values (and of exceptions) in a more intuitive way than what is
provided in raw format in the types as they are generated by the
analyzer. For example, universally quantified row variables that
appear only in positive occurrence are removed and annotations tagged
by presence variables universally quantified only in positive
occurrence are removed to make their absence explicit. In this way,
results are more easily readable than when the
.BR ocamlexcl
command is used.

When launching
.BR ocamlexcli
with proper '.cme' files names, a requester is opened displaying all
the loaded files. Double-click on one of them will open 2 new
windows. The first one displays the signature of the opened
module. The second window displays the source of the related module.



.SH OPTIONS
The following command-line options are recognized by
.BR ocamlexcli (1).

.TP
.BI \-I \ directory
Add the given directory to the list of directories searched for
the analyzed files. Directories added with 
.B \-I
are searched in the order in which they were given on the command
line. By default, only the current directory is searched.

.TP
.B \-forcevars
Forces "empty variables" to be displayed. Indeed, this option allows
to disable the type expressions simplification, providing the user
the same king of output than by using the
.BR ocamlexcl
command. The result of the analysis gets more difficult to read
(mainly dedicated to expert users) but hence allows the deep look in
the type expressions, while still having a graphical interface
allowing an easier navigation.



.SH THE MODULE SELECTION WINDOW
This window display the list of selected '.cme' files that are parts
of the analyzed program. By double clicking on their name, you can
pop up the related "interface" and "source" windows related to these
files.

The selection window also contains a
.I Misc
menu on the right upper part providing a small preferences
editor. This editor allows the user to configure the color schemes for
the display. Preferences can be either saved and applied either just
applied to the current session. When saved, a configuration file
called ".ocamlexcrc" is created in the user's home directory.



.SH THE FILE'S INTERFACE WINDOW
In this window, each component of the module is given an annotated
type that reflect possible values of this type. At the origin, types
are rolled so that they look like regular ML types. When a type is
underlined, this means it has an anchor on which is it possible to
click. Clicking on such an anchor will roll / unroll (toggle) the type
showing (hiding) values that can be present in this type. In the same
idea, function arrows can be underlined meaning that the function can
raise exceptions when applied. To inspect this set of exception, just
click on the related anchor. So, when a function type does not have
any anchor, this means that is cannot raise any exception.

Because some parts of type expressions can be shared between several
type expressions, rolling / unrolling a type allows to see this
sharing by rolling / enrolling it everywhere it appears. So don't be
surprised if clicking on an anchor affects another part of the type
expression you are inspecting.

Note on function types. An interesting effect of the type system used
by the analyzer is illustrated by the fact that a function with
several arguments (let's say 2) whose first arrow does not support any
exception, won't raise any exception when partially applied to one
argument. On the contrary, if the first arrow contains an anchor
annotated by a non empty set of exceptions, this means that when
partially applied to one argument, this function can raise
exceptions. To clearly understand this aspect of the analysis, let's
consider the 2 versions of a division function that tries to avoid
divisions by 0 by dividing it second argument by its first argument.

.I let div1 y x = if y = 0 then raise Div0 else x / y

.I let div2 y = if y = 0 then raise Div0 else function x -> x / y

The results we get are:

.I "val div1: int -> int -{}-> int"

.I "val div2: int -{}-> int -> int"

where arrows of the form -{}-> are annotated by an anchor. Then, once
fully unrolled, the types we get for these 2 functions are:

.I "val div1: int[0; `a] -> int -{Div0}-> int[_]"

.I "val div2: int[0; `a] -{Div0}-> int -> int[_]"

clearly showing that the first one will raise an exception as soon as
it knows that it will perform a division by 0, and that the second one
will raise this exception only when it knows its 2 arguments.



.SH THE SOURCE WINDOW
This window displays the source of the opened module as it was
formatted by the user. No more pretty printing is attempted. The user
can select a part of the source by left-clicking and dragging the mouse
over the text. If this portion of text corresponds to an expression of
the language, then a window will pop up, displaying the annotated type
and effect of this expression.

Hence this allows to walk in the source of the program to understand
where raised exceptions come from. These information must be
interpreted regarding the fact that is it generated from the internal
abstract tree of the program, and that the framework used by our
analyzer is unification-based. For example, if inspecting a condition
expression whose branch really raises an exception and the other one
does not, both of the 2 branches will be mentioned as raising the
exception (unification make bidirectional flow of information). To
better understand this aspect of the analysis, it is strongly
recommended to read the related research article
.I Type-based analysis of uncaught exceptions
by Francois Pessaux and Xavier Leroy - POPL99.
Please note that this remark is mainly devoted to advanced users.



.SH WINDOWS' COMMON FEATURES
In the 2 available windows provided by the browser, it is possible to
set
.BR marks
in the text for quick navigation. To do this, just select a
piece of text and then click on the
.I Set Mark
button in the upper part of the window. You can set as many marks you
want, each of them being local to the window where they have been
put. Then to navigate between marks, just select the one you want to
jump to in the
.I Jump Mark
menu of the upper part of the window.

Each window contains also a
.I Close
button allowing to close the current window if it is not needed
anymore.

In the same way, each window contains a
.I Quit
button to allow fast exiting of the browser. This closes all the
windows and terminates the browser.

Last, the
.I Search
button allows the user to look for a particular string in the
window. This feature can also be invocated by the
.I "Ctrl-S"
shortcut. Search can be done forward or backward depending on the
selected option (>> or << radiobutton in the search window). Search
can be also made case sensitive or case insensitive by checking the
appropriate option (a=A or a <> A radiobutton in the search
window). By default, search is forward, case insensitive. To reach the
next occurrence of the searched string, just press the
.I Enter key
in the search window. Finally to end a search, press the
.I Abort
button or use the
.I Ctrl-G
shortcut.




.SH HOW TO INTERPRET THE OUTPUT
For more informations please consult the manual page related to the
.BR ocamlexcl(1)
command.



.SH THE BASIC PROCEDURE TO ANALYZE A PROGRAM
The exception analysis is splitted in two passes. First, each source
file of the program must be pre-analyzed in a separate way, using the
.BR ocamlexcc
command. This generates '.cme' files ('foo.ml' will be analyzed and a
file called 'foo.cme' will be generated) that contain the partial
result of the uncaught exceptions analysis. The complete analysis
results cannot yet be known because they can depend on the results of
the analysis for the others files. However, once a file has been
analyzed, so long it does not change there is no need to re-analyze
it.
Once all the source files of the program are analyzed, it is possible
to get the final result of the analysis by applying the "linking"
pass. This is achieved by using either the
.BR ocamlexcl
or
.BR ocamlexcli
command. For more details on these command, please consult the
dedicated man page. These two commands perform basically the same
thing : merging all the partial results coming from the '.cme' files
previously generated by
.BR ocamlexcc
and displaying the result of the analysis. The first command displays
this result as text on the standard output. The second provides the
user a graphical browser, menu-window-mouse-driven. This second way to
look at the result of the analysis is much more convenient. It
provides several features to help reading types of the program, by
allowing folding/unfolding of these types (that can be really be big).



.SH ADVANCE USE : HOW TO SPECIFY TYPES FOR EXTERNAL PRIMITIVES
This section is mainly devoted to advanced users, may be who
understand the underlying principle of the analysis. We will now
explain how it is possible to define the type of external
definition. A good example can be found in the files of the standard
library, that are provided with the analyzer (mainly in the
'pervasives.ml' file.
Basically, you'll have to write the type of the primitive, the same
way it is done in standard Objective Caml. The only difference is that
instead of using standard types expressions, you will use "annotated"
type expression like those given as results by the analyzer. You will
have to follow the rules explained in the section describing how to
interpret the results (that is, use of the
.I "_"
annotation, enumeration of all constructors in case of a type with a
finite signature, use of presence annotations, and so on).

The arrow type, supporting the exceptions that can be raised by a
function during its application is written
.I "<[...]->"
instead of simply
.I "-{}->"
as it is in the results of the analysis. The reason for this is to
avoid conflicts in the syntax.

An extension of notation is provided to specify recursive types. You are
now allowed to write something like :
.I "external v : 'a <[`a]-> 'a with 'a = int[_] = \N'34'myprimitive\N'34'"
This allows to propagate sharing between type expressions. In the
case shown above, the resulting type will be equivalent to
.I "val v : int[_] -{`a}-> int[_]"
This way, you can specify the type of a function computing the size of
a list by :
.I "external length2 : 'b <[`a]-> int[_] \
   with 'b = 'a list [[] : Pre ; :: ('a * 'b) ; `b] \
   = \N'34'my_primitive\N'34'"
Then, if you ask the analyzer for the type of
.I "lenght2"
you will be answered :
.I "val length2 : \
   TY0 -{`a}-> int[_] \
     where TY0 = _'a list[[]:Pre; :: (_'a * TY0); _`b]"
By the way, you can notice the underscore (
.I "_"
) that sometimes can appear in front of the variables. Like in
Objective Caml, this means that the variable is not generalized, due
to the standard restriction on value. For more informations about this
fact, please consult the Objective Caml FAQ and documentation.

The type of tuple is simply the annotated type of each of the components
of the tuple. For example, the expression
.I "let x = ((if ... then 1 else 2), true) "
will have type
.I "val x : int[1:Pre; 2:Pre; `a] * bool[true:Pre; `b]"

The last extension in the syntax used to specify type expressions is
the annotation of record types. To specify such a type it is simply
needed to provide the annotated type of each of the field of the
record. For example, let's consider the following type declaration:
.I "type t = { foo : int ; bar : bool }"
An external value of this type can be defined by
.I "external v : t[{foo:int[_]; bar:bool[true:Pre; `a] }; `b] = \N'34'my_prim\N'34'"

In the same way, the pre-defined type
.I "ref"
for references (that is pointers) can be defined by
.I "type 'a ref = { mutable contents: 'a }"
So it is now possible to specify the type of the 3 primitives on this
type (that is creation of a reference, de-referenciation and
affectation) by the following definitions:
.sp
.I "external ref : 'a <[`a]-> 'a ref [{ contents : 'a }; `b] =\
\N'34'%makemutable\N'34'"
.sp
.I "external (!): 'a ref[{ contents : 'a }; `a] <[`b]-> 'a =\
\N'34'%field0\N'34'"
.sp
.I "external (:=): 'a ref[{ contents : 'a }; `a] <[`b]-> \
                           'a <[`c]-> \
                           unit[() :Pre; `d] = \N'34'%setfield0\N'34'"

as it is written in the 'pervasives.ml' file of the standard library.

As a summary, writing such things is only required for definitions
declared a "external", that means that cannot or are not written in
the Objective Caml language (because they are primitives, or for other
reasons).



.SH SEE ALSO
.BR ocamlexcc (1),
.BR ocamlexcl (1),
.BR ocamlexcli (1),
.BR ocamlexc (1).
.br
.I The Objective Caml user's manual,
for the general Objective Caml language description.
.br
.I Type-based analysis of uncaught exceptions
by Francois Pessaux and Xavier Leroy - POPL99.
